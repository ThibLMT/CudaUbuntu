/**
 *\file main.c          \brief main function                               
 *\version $Revision: 1.65 $  $Date: 2013/07/16 18:07:23 $ 
 */
/**************************************************************************
 *  demGCE in-house code					  	   *
 *  Discrete element modeling of Granular materials for Civil Engineering  *
 *				   			                   *
 * Developped by the civil and Environmental Engineering Department        *
 * Research centre of Ecole Mines Douai, France                            *         	                   
 * IDDN.FR.010.0118996.000.R.A.2013.035.30000        	                   *
 * 
 * Parallelisation du code - Maison de la Simulation *
 * version du 25/09/2013 *
 ***************************************************************************/ 



// General definitions
//********************
// Standard library inclusions

#include <time.h>
#include <omp.h>


// Project inclusion
#include "def_types.h"
#include "def_global_variables.h"

// Declaration of the functions
//*****************************
// Insertion of the header files linking extern functions with corresponding source files (*.c) 
#include "list_header_files.h"

// Functions used to generate sphere packing and boundary conditions
void boundary_conditions(void);
void add_cylinder(void);
void particles_properties(void);
struct sphere wall_properties(struct sphere part_wall);

// Functions of the DEM computation -> integrate contains the DEM loop and check used to detect the contacts
void dem_computing(void);
double num_coor();
void output_data(int istep,double timet);


// Function to run program
void end_program(void);
static void print_about(void);

/**
 *\fn int main(int argc, char *argv[])
 *\brief main function or the program
 *\param argc number of arguments supplied to the program
 *\param *argv  Arguments supplied to the program	
 *\return EXIT_SUCCESS  - Normal stop of the program
 */

int main(int argc, char *argv[])
{
  char Nlogfile[50]="logfile";
  // Initialization of some global variables
  //** Flag variables
  Nparafile="params.in";	
  int i,j,k,k1;
  int nb_taches;
  Flag module_computing=false;
  Flag module_generating=false;
	
	
  // Initialization of Ierror
  ierror=EXIT_SUCCESS;
	
  // Function called by exit() function for both failure or sucess cases
  atexit(end_program);
	
  // Treatement of the main() arguments 
  if (argc>1)
    {
      if (!strcmp (argv[1],"-about"))
	{
	  print_about();
	  return 0;
	}
      else if (!strcmp (argv[1],"-file"))
	{
	  Nparafile=argv[2];
	}
      else if (!strcmp (argv[1],"-comp"))
	{
	  module_computing=true;
	}
      else 
	{
	  fprintf(stdout,"%s is not a valid option \n",argv[1]);
	  fprintf(stdout,"list of available options : \n");
	  fprintf(stdout,"  -file Name_of_parameter_file \n");
	  fprintf(stdout,"  -about \n");
	  return 0;
	}
    }
	
  // Open first the log file (history of simulation)	
  flogfile=fopen(Nlogfile,"w");
  fprintf(flogfile,"***********************************\n");
  fprintf(flogfile,"* demGCE code : log file \n");
  fprintf(flogfile,"  Compilation "__DATE__" a "__TIME__"\n");
  
  
#ifdef _OPENMP
#pragma omp parallel
  {
#pragma omp master
    {
      nb_taches = omp_get_num_threads() ;
    }
  }
  fprintf (flogfile,"** parallel execution : %d thread(s) **", nb_taches) ;
  fprintf (stdout,"** parallel execution : %d thread(s) **", nb_taches) ;
#endif
	
  // Run program according to two operator's choices : from file parameter, or step by step via linux terminal
  if(flogfile != NULL)
    {

      // Computing in terminal according to data from parameter file
      read_param();
		
      // If Freadmicro, get some information from microstructure file before the allocation
      if(Freadmicro)
	{
	  read_micro(FichMicroInitiale, FichContInitiale,0);
	}

      // Allocatation of mic array and intialization of variables
      allocate_variables();
      
#pragma omp parallel for private(i,k) shared(particle,npart,nobj)
      for(i=0;i<=npart+nobj;i++) 
	{
	  particle[i].Ri.x=0.0;	// vector
	  particle[i].Ri.y=0.0;
	  particle[i].Ri.z=0.0;
	  particle[i].Vi.x=0.0;	// vector
	  particle[i].Vi.y=0.0;
	  particle[i].Vi.z=0.0;
	  particle[i].Ai.x=0.0;	// vector
	  particle[i].Ai.y=0.0;	// vecto
	  particle[i].Ai.z=0.0;	// vecto
	  particle[i].Wi.x=0.0;		// vector
	  particle[i].Wi.y=0.0;		// vector
	  particle[i].Wi.z=0.0;		// vector
	  particle[i].Aroti.x=0.0; 	// vector
	  particle[i].Aroti.y=0.0;
	  particle[i].Aroti.z=0.0;
	  particle[i].Fi.x=0.0;   // vector
	  particle[i].Fi.y=0.0;
	  particle[i].Fi.z=0.0;
	  particle[i].Mi.x=0.0;		// vector
	  particle[i].Mi.x=0.0;
	  particle[i].Mi.x=0.0;
	  particle[i].radius=0.0;		// double
	  particle[i].mass=0.0;		// double
	  particle[i].inertia=0.0;	// double
	  particle[i].Yn=0.0;	//double
	  particle[i].Nu=0.0;		// double
	  particle[i].Ndamp=0.0;		// double
	  particle[i].Mu=0.0;	// double
	  particle[i].Mur=0.0;	// double
	  particle[i].next=0;	// int
	  particle[i].clust=0;    // int
	  for(k=0;k<MAXCONT;k++){particle[i].contact[k]=0;}	// Int array
	  for(k=0;k<MAXCONT;k++){particle[i].ut[k]=0.0;}			// double array
	  for(k=0;k<MAXCONT;k++){particle[i].ftanold[k].x=0.0;}	//vector array
	  for(k=0;k<MAXCONT;k++){particle[i].ftanold[k].y=0.0;}	//vector array
	  for(k=0;k<MAXCONT;k++){particle[i].ftanold[k].z=0.0;}	//vector array
	  for(k=0;k<MAXCONT;k++){particle[i].nijold[k].x=0.0;	}	//vector array
	  for(k=0;k<MAXCONT;k++){particle[i].nijold[k].y=0.0;}
	  for(k=0;k<MAXCONT;k++){particle[i].nijold[k].z=0.0;}
	  for(k=0;k<MAXCONT;k++){particle[i].type[k]=0;}
	}
 


      // Boundary conditions
      boundary_conditions();

      // PK : copy mic_boundary into mic (only enable for walls)
      for(i=0;i<syssizex;i++)
	for(j=0;j<syssizey;j++)
	  for(k=0;k<syssizez;k++)
	    for (k1=0; k1<ncont; k1++)
	      mic[i][j][k][k1] = mic_boundary[i][j][k][k1];
	      
      for(i=0;i<syssizex;i++)
	for(j=0;j<syssizey;j++)
	  for(k=0;k<syssizez;k++)  
	    mic_insert[i][j][k]=mic_insert_boundary[i][j][k];
      
      
    // read microstructure of particles  
	  read_micro(FichMicroInitiale, FichContInitiale,1);
	
	// get properties
      particles_properties();
			
		
		

      if(ChoixTypeCalcul==0)
	{
	  //n  Only particles generation 
	  // Generating initial micro and vtk files
	  write_micro("micro_0000",true);
	  write_vtk("spheres_0000.vtk");
	  if(Fwall){write_wall_vtk("walls_0000.vtk");}
	  if(Fcyl_bond){write_cyl_vtk("cyl_0000.vtk");}
	  if(Fsph_obj){write_obj_vtk("objects_0000.vtk");}
	  exit(EXIT_SUCCESS);
	}
		
      // Start dem simulation
      dem_computing();
      //integrate();
			
      // End of the computation with the deallocation of the variables
      exit(errno);

    }
  else
    {
      perror(Nlogfile);
      exit(ierror=errno);
    } 
  return EXIT_SUCCESS;
}

//*****************	
// functions
//************
// Functions used to generate sphere packing and boundary conditions
//******************************************************************

/**
 *\fn void boundary_conditions(void)
 *\brief function to set up the boundary conditions
 *\param void	
 *\return void
 */


void boundary_conditions(void)
{
  vector vnwall,Xp;
  unsigned int i, isurf;
  fprintf(stdout,"\n  List of the boundary conditions\n");
  fprintf(stdout,"=================================\n");
  fprintf(flogfile,"\n  List of the boundary conditions\n");
  fprintf(flogfile,"=================================\n");
	
  box_size.x=(double)syssizex;
  box_size.y=(double)syssizey;
  box_size.z=(double)syssizez;
	
  if(state_obj[1]==1)
    {
      // add wall x=0	 isurf=2
      isurf=2;
      Xp.x=0;
      Xp.y=syssizey/2.0;
      Xp.z=syssizez/2.0;

      vnwall.x=-1.0;
      vnwall.y=0.0;
      vnwall.z=0.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.x-=0.5;
    }	
	
  if(state_obj[2]==1)
    {
      // add wall x=syssizex-1 isurf=3
      isurf=3;
      Xp.x=syssizex-1;
      Xp.y=syssizey/2.0;
      Xp.z=syssizez/2.0;
						
      vnwall.x=1.0;
      vnwall.y=0.0;
      vnwall.z=0.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.x-=0.5;
    }	
	
  if(state_obj[3]==1)
    {			
      // add wall y=0  isurf=4
      isurf=4;
      Xp.x=syssizex/2.0;
      Xp.y=0.0;
      Xp.z=syssizez/2.0;
      vnwall.x=0.0;
      vnwall.y=-1.0;
      vnwall.z=0.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.y-=0.5;
    }
	
  if(state_obj[4]==1)
    {
      // add wall y=syssizey-1 isurf=5
      isurf=5;
      Xp.x=syssizex/2.0;
      Xp.y=syssizey-1;
      Xp.z=syssizez/2.0;
      vnwall.x=0.0;
      vnwall.y=1.0;
      vnwall.z=0.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.y-=0.5;
    }
	
  if(state_obj[5]==1)
    {
      // add wall z=0	isurf=1
      isurf=1;
      Xp.x=syssizex/2.0;
      Xp.y=syssizey/2.0;
      Xp.z=0.0;
      vnwall.x=0.0;
      vnwall.y=0.0;
      vnwall.z=-1.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.z-=0.5;
    }
	
  if(state_obj[6]==1)
    {
      // add wall z=syssizez-1 - isurf=6
      isurf=6;
      Xp.x=syssizex/2.0;
      Xp.y=syssizey/2.0;
      Xp.z=syssizez-1;
      vnwall.x=0.0;
      vnwall.y=0.0;
      vnwall.z=1.0;
      particle[npart+isurf]=add_wall(npart+isurf,Xp,vnwall);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
      box_size.z-=0.5;
    }
	
  if(state_obj[7]==1)
    {
      // add cylinder along the z axe - isurf=7
      add_cylinder();
      isurf=7;
      particle[npart+isurf]=wall_properties(particle[npart+7]);
    }

  if(state_obj[8]==1)
    {
      // add cone along the z axe - isurf=8
      isurf=8;
      add_cone(npart+isurf);
      particle[npart+isurf]=wall_properties(particle[npart+isurf]);
    }

  if(state_obj[nsurf+1]==1)
    {
      add_obj_spheres(Nobjfile,npart+nsurf+1,false);
      for(i=npart+nsurf+1;i<=npart+nobj;i++)
	{
	  particle[i]=wall_properties(particle[i]);
	}

    }
  fprintf(stdout,"  system size : %d %d %d \n",syssizex,syssizey,syssizez);
  fprintf(stdout,"  box_size : %5.2f %5.2f %5.2f \n",box_size.x,box_size.y,box_size.z);
  fprintf(stdout,"  Unity : %e m \n",unity);
} 
	
	


	
/**
 *\fn void add_cylinder(void)
 *\brief function to add cylindrical boundary condition (alonz z axe)
 *\param void	
 *\return void
 */
		
void add_cylinder(void)
/* Calls: no other routines */
/* Called by: main program */
{
  int i,j,k,nwall;
  double dist,distmin,distmax,x0,y0,x1,y1;

  diamcyl=diamcyl-2.0;
  nwall=npart+7;
  x0=syssizex/2.0;
  y0=syssizey/2.0;

  for(i=0;i<syssizex;i++)
    {
      for(j=0;j<syssizey;j++)
	{
	  distmax=0.0;
	  distmin=1000.0;
	  x1=(float)i;
	  y1=(float)j;
	  dist=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	  if(dist<distmin){distmin=dist;}
	  if(dist>distmax){distmax=dist;}
	  x1=(float)i-0.5;
	  y1=(float)j+0.5;
	  dist=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	  if(dist<distmin){distmin=dist;}
	  if(dist>distmax){distmax=dist;}
	  x1=(float)i+0.5;
	  y1=(float)j-0.5;
	  dist=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	  if(dist<distmin){distmin=dist;}
	  if(dist>distmax){distmax=dist;}
	  x1=(float)i+0.5;
	  y1=(float)j+0.5;
	  dist=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	  if(dist<distmin){distmin=dist;}
	  if(dist>distmax){distmax=dist;}
	  x1=(float)i-0.5;
	  y1=(float)j-0.5;
	  dist=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	  if(dist<distmin){distmin=dist;}
	  if(dist>distmax){distmax=dist;}
	  if((diamcyl-hmax)/2.0<distmax)
	    {
	      for(k=0;k<syssizez;k++)
		{
		  if(mic[i][j][k][0]==0)
		    {mic[i][j][k][0]=nwall;}
		  else{mic[i][j][k][1]=nwall;}
		}
	    }
	}
    }
  diamcyl=diamcyl+2.0;
		
  particle[nwall].radius=1000000.0;
  particle[nwall].Ri.x=syssizex/2.0;
  particle[nwall].Ri.y=syssizey/2.0;
  particle[nwall].Ri.z=-particle[nwall].radius;

  particle[nwall].Vi=vect0;
  particle[nwall].Wi=vect0;

  particle[nwall].Fi=vect0;
  particle[nwall].Mi=vect0;
	
	
  // printing some information for logfile and screen
  fprintf(stdout,"cylinder : id %d - Center %3.2f %3.2f %3.2f - axe 0 0 1 - Dia %f Length %d\n",nwall,x0,y0,((double)syssizez)/2.0,diamcyl,syssizez);
  fprintf(flogfile," Characteritics of the cylinder - id:%d \n",nwall);
  fprintf(flogfile," =======================================\n");
  fprintf(flogfile,"cylinder : id %d - Center %3.2f %3.2f %3.2f \n axe 0 0 1 - Dia %3.2f Length %d\n",nwall,x0,y0,((double)syssizez)/2.0,diamcyl,syssizez);
}
		
/**
 *\fn void particles_properties(void)
 *\brief function to set the properties of the particles
 *\param void	
 *\return void
 */		
		
void particles_properties(void)
{
  unsigned int k;
  double massred;
  double hpaste;
	
  for(k=1;k<=npart;k++)
    {
      particle[k].mass=4.0/3.0*PI*(particle[k].radius)*(particle[k].radius)*(particle[k].radius)*unity*unity*unity;
      particle[k].mass=particle[k].mass*density;
      particle[k].inertia=0.4*particle[k].mass*particle[k].radius*particle[k].radius*unity*unity;
      if(forceHCSS)
	{
	  // In the case of the ForceHCCS, the mass of soft shell is taken into account 
	  hpaste=hmax;
	  particle[k].mass=4.0/3.0*PI*(particle[k].radius+hpaste/2.0)*(particle[k].radius+hpaste/2.0)*(particle[k].radius+hpaste/2.0)*unity*unity*unity*paste_density;
	  massred=4.0/3.0*PI*(particle[k].radius)*(particle[k].radius)*(particle[k].radius)*unity*unity*unity*(density-paste_density);
	  particle[k].inertia=0.4*massred*particle[k].radius*particle[k].radius*unity*unity;
	  particle[k].inertia+=0.4*particle[k].mass*(particle[k].radius+hpaste/2.0)*(particle[k].radius+hpaste/2.0)*unity*unity;
	  particle[k].mass=particle[k].mass+massred;
	}
		
      particle[k].Yn=kn;
      particle[k].Nu=nu;
      particle[k].Ndamp=cn;
      particle[k].Mu=mu_gg;
      particle[k].Mur=mu_roll_gg;
    }

  // Writing some information in stdout and logfile
	
  fprintf(stdout,"\n\n  Assignment of material properties for the particles \n");
  fprintf(stdout,"====================================================\n");
  fprintf(stdout,"  Only one material\n");
  fprintf(flogfile,"\n\n  Assignment of materialproperties for the particles \n");
  fprintf(flogfile,"====================================================\n");
  fprintf(flogfile,"  Radius %e",particle[1].radius);
  fprintf(flogfile,"\t Mass %e",particle[1].mass);
  fprintf(flogfile,"\t Inerty %e \n",particle[1].inertia);
  fprintf(flogfile,"  Normal reduced modulus %e",particle[1].Yn);
  fprintf(flogfile,"\t Poisson's ratio %1.3e",particle[1].Nu);
  fprintf(flogfile,"\t Normal damping coef. %e \n",particle[1].Ndamp);
  fprintf(flogfile,"\t  Friction coef. %e \n",particle[1].Mu);
  fprintf(flogfile,"  Rolling friction coef. %e",particle[1].Mur);
  fprintf(flogfile,"\n");
} /* Fin du programme particles_properties.c */


/**
 *\fn struct sphere wall_properties(struct sphere part_wall)
 *\brief function to set the properties of the wall
 *\param struct sphere	
 *\return struct sphere
 */		

struct sphere wall_properties(struct sphere part_wall)
{
  // 	Affectation des proprietes physiques, micromecaniques et physico-chimiques							
  part_wall.mass=4.0/3.0*PI*pow(part_wall.radius,3.0)*pow(unity,3.0);
  part_wall.mass=part_wall.mass*density;
  part_wall.inertia=0.4*part_wall.mass*pow(part_wall.radius,2.0)*pow(unity,2.0);
  part_wall.Yn=kn;
  part_wall.Nu=nu;
  part_wall.Ndamp=cn;
  part_wall.Mu=mu_gw;
  part_wall.Mur=mu_roll_gw;
	  						
  // Printing wall characteristics in the log file 
					
		
  fprintf(flogfile," Radius : %e \t",part_wall.radius);
  fprintf(flogfile," Mass : %e \t",part_wall.mass);
  fprintf(flogfile," Inerty : %e \n",part_wall.inertia);
  fprintf(flogfile," Module reduit n : %e \t",part_wall.Yn);
  fprintf(flogfile," Coef. Poisson : %e \t",part_wall.Nu);
  fprintf(flogfile," Amort normale : %e \n",part_wall.Ndamp);
  fprintf(flogfile," Coef. frottement  : %e \n",part_wall.Mu);
  fprintf(flogfile," Coef. roulement   : %e \t",part_wall.Mur);
  if((part_wall.Vi.x!=0.0)||(part_wall.Vi.y!=0.0)||(part_wall.Vi.z!=0.0))
    {fprintf(flogfile,"  Mobil wall\n");}
  else {fprintf(flogfile,"  fix wall\n");}
		
  return part_wall;
		
} /* Fin du programme wallsproperties.c */



//*****************************************	
// DEM computing
//*****************************************

void dem_computing(void)
{
  int i,j,k,l,indvox,index_insert,index_backgrid;
  int k4,kzplateau,co;
  unsigned int k1,k2,k3,ivox,jvox,kvox,kp,idparti,idpartj;
  double xpartx,xparty,xpartz,radpart,rad2part,dist2;
  int ivtk,imicro;   //!< Digit of the output files
  vector Rimax; //!< Position of the particle localized at the extremun of the granular media along each axe
  unsigned int ncontactperpart,icontact,icontactbis,ilist;
  unsigned int list_part[MAXCONT];
  Flag test_contact,test_new_contact;
  double sxy,timet; 
  double vplateau;
  double vmin,ncoord;
  double *freturn;  //!< Pointer uses for returned data arrays from function
  unsigned int ncontpot; //!<Number of the potential contacts at each time step (number of contacts checked by choc function)
  // Force and torque exerced by the fluid to the particle and velocity and vorticity of the fluid
  vector ffluid; //!< fluid force
  vector torqflu; //!< torque fluid
  vector vflu; //!< Fluid velocity
  vector vorflu; //!< Fluid voticity
  // Force and torque exerced by the particle j on part i
  vector forceji;  //!< Interaction force exerced by part j to part i
  vector torqueji; //!< Interaction torque exerced by part j to part i
	
  // Force, stress, displacement and strain linked to the boundary conditions
  double flatcyl;  //!< Lateral force applied inside of the cylinder boundary conditions 
  double sr_latcyl;  //!< Lateral stress (applied on the cylinder boundary conditions)
  double sr_supwall; //!< Upper stress (upper wall)
  double z_upwall; //!< Z position of the upper wall.
  double delta_stress; //!< Differnce between the stress and the required one
  double a_lame,b_lame; //!< Respectively the upper and tehe inner diameter for the cylinder
  double deltar;
  // Name and declaration of the result files
  char filename[50];
  // Initialization or the array for data returned data (from choc and cluster_properties functions)
  freturn = malloc (10 * sizeof( *freturn));
  
  

  // Writing some information in stdout and logfile before the loop time computation
  fprintf(stdout,"\n  Starting demGCE simulation \n");
  fprintf(stdout,"=============================================\n");
  fprintf(flogfile,"\n  Starting demGCE simulation \n");
  fprintf(flogfile,"=============================================\n");

  fflush(flogfile);
  
    
  // Initialization before the time loop
  // Private variables
  ffluid=vect0;
  torqflu=vect0;
  vflu=vect0;
  vorflu=vect0;
  forceji=vect0;
  torqueji=vect0;
  
  //**Initialization of time variables
  istep=1;
  timet=0.0;
  imicro=0;
  ivtk=0;

  // Computation of Average values at the first time step
  
  // Generating initial vtk files for boundary conditions

  fflush(stdout);
  fflush(flogfile);
  
  // Initialization of the background grid
  syssizel=ncont;
 
  
  fflush(stdout);
  // Malloc backgrid,backgrid_insert tableau
  alloc_backgrid(backgrid,backgrid_insert);
  
#pragma omp parallel shared(backgrid_insert,syssizex,syssizey,syssizez) private(indvox)
  {
#pragma omp for    
    for(indvox=0;indvox<syssizex*syssizey*syssizez;indvox++) 
      {backgrid_insert[indvox]=0;}
    
    
#pragma omp for
    for(indvox=0; indvox<syssizex*syssizey*syssizez*syssizel;indvox++) 
      {backgrid[indvox]=0;}
  }

  // Insert boundary (bottom wall for test npart+1)
  idparti=npart+1;
  for(i=0;i<syssizex;i++)
    {
      for(j=0;j<syssizey;j++)
	{
	  set_idp_backgrid(i,j,0,idparti,backgrid,backgrid_insert);
			
	}
			
    }
	
  // Case 1 Insert the sphere ID in backgrid array subarea (loop on the particles)

  for(idparti=1;idparti<=npart;idparti++)
    {
      xpartx=particle[idparti].Ri.x;
      xparty=particle[idparti].Ri.y;
      xpartz=particle[idparti].Ri.z;
      radpart=particle[idparti].radius+hmax/2.0;
      insert_sphere_backgrid(xpartx,xparty,xpartz,radpart,idparti,backgrid,backgrid_insert);
    } 
    
	
	
	
  // Starting of the time loop
  do
    {	
      //***********************************************************
      //reset forces for all the particles and the boundary conditions (objects and surfaces) 

#pragma omp parallel for shared(particle,npart,nobj,vect0) private(idparti) schedule(static)
      for(idparti=1;idparti<=npart+nobj;idparti++)
	{
	  particle[idparti].Fi=vect0;
	  particle[idparti].Mi=vect0;
	}
	 
      //***********************************************************
      // compute forces for all the particles
      // Loop to compute the volumic forces

#pragma omp parallel for shared (npart,particle) private(idparti,ffluid) firstprivate(gravity,forceFluid,ChoixTypeCalcul,vflu,Vflumax,syssizex,vect0,torqflu,vorflu) default(none)
      for(idparti=1;idparti<=npart;idparti++)
	{		
	  // Gravity force
	  particle[idparti].Fi.x+=gravity.x*particle[idparti].mass;
	  particle[idparti].Fi.y+=gravity.y*particle[idparti].mass;
	  particle[idparti].Fi.z+=gravity.z*particle[idparti].mass;
			
	  // Hydraudynamic forces (conditions of fluid inside of the functions, need to be change)
	  if(forceFluid)
	    {
	      if(ChoixTypeCalcul==2)
		{
		  // Vecteur vitesse fluide : ecoulement suivant l'axe y (shear rate=2*vflumax/syssizex)
		  vflu.x=0.0;
		  vflu.y=Vflumax*((2.0/syssizex)*particle[idparti].Ri.x-1.0);
		  vflu.z=0.0;
		}
	      else{vflu=vect0;}
	      // Computing fluid forces (Stokes and Buoyancy)
	      ffluid=fluid_force(particle[idparti].radius,particle[idparti].Vi,vflu);
	      particle[idparti].Fi.x+=ffluid.x;
	      particle[idparti].Fi.y+=ffluid.y;
	      particle[idparti].Fi.z+=ffluid.z;
	      // Computing fluid torque
	      torqflu=fluid_torque(particle[idparti].radius,particle[idparti].Wi,vorflu);
	      particle[idparti].Mi.x+=torqflu.x;
	      particle[idparti].Mi.y+=torqflu.y;
	      particle[idparti].Mi.z+=torqflu.z;
	    }
	}
	   
      // Loop to compute the interaction forces

#pragma omp parallel for shared (npart,particle,hmax,syssizex,syssizey,syssizez,syssizel,backgrid) private(forceji,torqueji,icontact,icontactbis,ilist,idparti,idpartj,xpartx,xparty,xpartz,radpart,ncontactperpart,list_part,test_contact,test_new_contact) schedule(static)
      for(idparti=1;idparti<=npart;idparti++)
	{
	  xpartx=particle[idparti].Ri.x;
	  xparty=particle[idparti].Ri.y;
	  xpartz=particle[idparti].Ri.z;
	  radpart=particle[idparti].radius;
	
	    
	  // detect the particles in contact with the particle idparti and store the id in list_part[] array and the number of contacts per particle
	  memset(list_part,0,MAXCONT*sizeof(unsigned int));

	  ncontactperpart=detect_contact_sphere_backgrid(xpartx,xparty,xpartz,radpart+hmax/2.0,idparti,list_part,backgrid);

	  // Loop foor on the if of particles in contact with the particle	idparti 
	  // Computing the interaction forces for each contact
	  for(ilist=0;ilist<ncontactperpart;ilist++)
	    {
	      icontact=0;
	      idpartj=list_part[ilist];
	      // test if new contact and grep the position i contact and the identifiant in particle[ni].contact[icontact] array
	      test_new_contact=false;
	      test_contact=false;
	      do{
		if(particle[idparti].contact[icontact]==idpartj)
		  {
		    // Contact already exist - mark the id as negative number to keep the contact in the second loop
		    particle[idparti].contact[icontact]=-idpartj;
		    test_contact=true;
		  }
		else if (particle[idparti].contact[icontact]==0)
		  {
		    // New contact - mark the id as negative number to keep the contact in the second loop
		    test_contact=true;
		    test_new_contact=true;
		  }
		//printf("\n icont %d particle[idparti].contact[icontact] %d \n",icontact,particle[idparti].contact[icontact]);
		icontact+=1;
			  
	      }
	      while(!test_contact);
	      // decriment icontact
	      icontact-=1;
	      // mark the id of new contact as negative number to keep the contact in the second loop
	      if(test_new_contact){particle[idparti].contact[icontact]=-idpartj;}
	      // Compute interaction force between parti and partj
	      particle_interactions(idparti,idpartj,icontact,&(forceji),&(torqueji));
			
	      // adpate the sum Fext->i
	      particle[idparti].Fi.x+=forceji.x;
	      particle[idparti].Fi.y+=forceji.y;
	      particle[idparti].Fi.z+=forceji.z;
		    
	      particle[idparti].Mi.x+=torqueji.x;
	      particle[idparti].Mi.y+=torqueji.y;
	      particle[idparti].Mi.z+=torqueji.z;
		    
	      // Add the balanced force for boundary conditions
	      
	      if(idpartj>npart)
		{
                #pragma omp critical
                {
		particle[idpartj].Fi.x-=forceji.x;
		particle[idpartj].Fi.y-=forceji.y;
		particle[idpartj].Fi.z-=forceji.z;
		    
		particle[idpartj].Mi.x+=torqueji.x;
		particle[idpartj].Mi.y+=torqueji.y;
		particle[idpartj].Mi.z+=torqueji.z;
		     }
		}
	    }
	       
	  // remove contact from list, for particles that have been separated during the last time step 	    
	  icontact=0;
	  do	{
	    if(particle[idparti].contact[icontact]<0)
	      {
		particle[idparti].contact[icontact]=-particle[idparti].contact[icontact];
		icontact+=1;
	      }
	    else if(particle[idparti].contact[icontact]>0)
	      {
		icontactbis=icontact;
					
		do
		  {
		    particle[idparti].contact[icontactbis]=particle[idparti].contact[icontactbis+1];
		    particle[idparti].ut[icontactbis]=particle[idparti].ut[icontactbis+1];
		    particle[idparti].ftanold[icontactbis]=particle[idparti].ftanold[icontactbis+1];
		    particle[idparti].nijold[icontactbis]=particle[idparti].nijold[icontactbis+1];
		    icontactbis+=1;
		  }
		while(particle[idparti].contact[icontactbis]!=0);
	      }
					
	  }
	  while(particle[idparti].contact[icontact]!=0);
	}
	
	
	// 
	


	  
      //***********************************************************
      // Postprocessing - Interaction forces and geometrical parameters    
      if((istep%ndowrite==0)||(istep%ndodisplay==0)||(istep==1)||istep==niter)
	{  
	output_data(istep,timet);
	sprintf(filename,"micro_%04d",imicro);
	imicro++;
	write_micro(filename,true);
	sprintf(filename,"spheres_%04d.vtk",ivtk);
	  write_vtk(filename);
	  ivtk++;
	
	} 
	  
      // Postprocessing - micro and vtk files
      // Writing of the microstructure and contact files
      if((istep==1)||((ndowritemicro!=0)&&(istep%ndowritemicro==0))||(istep==niter))
	{
	  /* sprintf(filename,"micro_%04d",imicro); */
	  /* write_micro(filename,true); */
	  /* fprintf(stdout,"    Writing micro file %s (ite %d)\n",filename,istep); */
	  /* fprintf(flogfile,"    Writing micro file %s ite %d\n",filename,istep); */
	  /* imicro++; */
	}

      //**************************************
      // Writing of the paraview files
      /*
      if((istep==1)||((ndowritevtk!=0)&&(istep%ndowritevtk==0))||(istep==niter))
	{	
	  sprintf(filename,"spheres_%04d.vtk",ivtk);
	  write_vtk(filename);
	  fprintf(stdout,"    Writing vtk files %s\t",filename);

	  if(Fwall_mov)
	    {
	      sprintf(filename,"walls_%04d.vtk",ivtk);
	      write_wall_vtk(filename);
	      fprintf(stdout,"%s\t",filename);
	    }

	  if(Fsph_obj)
	    {
	      sprintf(filename,"objects_%04d.vtk",ivtk);
	      write_obj_vtk(filename);
	      fprintf(stdout,"%s\t",filename);
	    }

	  if(Fcyl_mov)
	    {
	      sprintf(filename,"cyl_%04d.vtk",ivtk);
	      write_cyl_vtk(filename);
	      fprintf(stdout,"%s\t",filename);
	    }
	  fprintf(stdout,"(ite %d)\n",istep);
	  ivtk++;
	}	
   */
      //**********
      //  Update particle position for the next ime step - loop on the particle
      // Semi-implicite euler scheme
      // ai(t)=1/mi*sum(Fext->i)
      // vi(t+dt)=vi(t)+ai(t)*dt
      // xi(t+dt)=xi(t)+vi(t+dt)*dt
      // awi(t)=1/Ii*sum(Text->i)
      // wi(t+dt)=wi(t)+awi(t)*dt

#pragma omp parallel for shared(particle,syssizex,syssizey,syssizez,unity,deltat) private(idparti) schedule(static)
      for(idparti=1;idparti<=npart;idparti++)
	{
	  // ai(t)=1/mi*sum(Fext->i)
	  particle[idparti].Ai.x=particle[idparti].Fi.x/unity/particle[idparti].mass;
	  particle[idparti].Ai.y=particle[idparti].Fi.y/unity/particle[idparti].mass;
	  particle[idparti].Ai.z=particle[idparti].Fi.z/unity/particle[idparti].mass;

	  // vi(t+dt)=vi(t)+ai(t)*dt
	  particle[idparti].Vi.x=(particle[idparti].Vi.x+particle[idparti].Ai.x*deltat);
	  particle[idparti].Vi.y=(particle[idparti].Vi.y+particle[idparti].Ai.y*deltat);
	  particle[idparti].Vi.z=(particle[idparti].Vi.z+particle[idparti].Ai.z*deltat);
			
	  // Computing of angular acceleration -> awi(t)=1/Ii*sum(Text->i)
	  particle[idparti].Aroti.x=particle[idparti].Mi.x*unity/particle[idparti].inertia;
	  particle[idparti].Aroti.y=particle[idparti].Mi.y*unity/particle[idparti].inertia;
	  particle[idparti].Aroti.z=particle[idparti].Mi.z*unity/particle[idparti].inertia;
							
	  // actualization of angular velocity -> wi(t+dt)=wi(t)+awi(t)*dt
	  particle[idparti].Wi.x=particle[idparti].Wi.x+particle[idparti].Aroti.x*deltat;
	  particle[idparti].Wi.y=particle[idparti].Wi.y+particle[idparti].Aroti.y*deltat;
	  particle[idparti].Wi.z=particle[idparti].Wi.z+particle[idparti].Aroti.z*deltat;

	  // actualization of position by checking the periodic condtition 
	  // xi(t+dt)=xi(t)+vi(t+dt)*dt
	  particle[idparti].Ri.x+=particle[idparti].Vi.x*deltat;		
	  if(particle[idparti].Ri.x>syssizex){particle[idparti].Ri.x-=syssizex;}
	  else if(particle[idparti].Ri.x<0.0){particle[idparti].Ri.x+=syssizex;}
	  
	  particle[idparti].Ri.y+=particle[idparti].Vi.y*deltat;
	  if(particle[idparti].Ri.y>syssizey){particle[idparti].Ri.y-=syssizey;}
	  else if(particle[idparti].Ri.y<0.0){particle[idparti].Ri.y+=syssizey;}

	  particle[idparti].Ri.z+=particle[idparti].Vi.z*deltat;
	  if(particle[idparti].Ri.z>syssizez){particle[idparti].Ri.z-=syssizez;}
	  else if(particle[idparti].Ri.z<0.0){particle[idparti].Ri.z+=syssizez;}
	}
	
      //**************************************
      // Moving boundary condition
      // Obj suppression fonction delete
      // reisncrption des conditions aux limites dans le tableau mic afin de supprimer mic_boundary
      memset(backgrid,0,syssizex*syssizey*syssizez*syssizel*sizeof(unsigned int));
      memset(backgrid_insert,0,syssizex*syssizey*syssizez*sizeof(int));
	
      // Ajout plan z=0 dans backgrid
      idparti=npart+1;
      for(i=0;i<syssizex;i++)
	{
	  for(j=0;j<syssizey;j++)
	    {
	      set_idp_backgrid(i,j,0,idparti,backgrid,backgrid_insert);
	    }
			
	}  
    
      //*****************************
      // write particle in sub-domain mic array
	
      // Insert the id of particle in mic sub-domain (2 cases)
      // Case 1 INSERT CHECK: loop on the particles


#pragma omp  parallel for shared(backgrid,backgrid_insert,particle,hmax,syssizex,syssizey,syssizez,syssizel,npart) private(idparti,xpartx,xparty,xpartz,radpart) schedule(static) 
      for(idparti=1;idparti<=npart;idparti++)
	{
	  xpartx=particle[idparti].Ri.x;
	  xparty=particle[idparti].Ri.y;
	  xpartz=particle[idparti].Ri.z;
	  radpart=particle[idparti].radius+hmax/2.0;
	  insert_sphere_backgrid(xpartx,xparty,xpartz,radpart,idparti,backgrid,backgrid_insert);
	} 

	
      // time incrementation
      timet+=deltat;
      istep+=1;  
    }while(istep<=niter);
    


  fprintf(stdout,"\n  End of the loop time \n");
  fprintf(stdout,"=============================================\n");
  fprintf(flogfile,"\n  End of the loop time \n");
  fprintf(flogfile,"=============================================\n");
  //ncoord=num_coor();
   fprintf(stdout,"\n  Coordination number %f \n",ncoord);
fflush(stdout);
  fflush(flogfile);
}







// Old check function with id=3 - detect contacts between idpart and other grains

void output_data(int istep,double timet)
{
  int idparti; //!w id of the particle i
  double vit_norm,wit_norm;
  int npwmax;  //!< Identity of the particle with the largest angular velocity and with it coordination number
  double nzcoor;  //!< Averaged coordination number
  vector Rimax,Rimin,Rimean; //!< Position of the particle localized at the extremun of the granular media along each axe
  double vmoy;
  double ecr,ecl,ecp;
  double wmax,vwmax;
  double wmoy;
  vector fobjects;
  double compacite;
  double sxy;
  double sr_supwall;
   
   
   
  // Call analysing fonction 
  vit_norm=0.0;
  wit_norm=0.0;
  wmax=0.0;
  vwmax=0.0;
  npwmax=0;
  vmoy=0.0;
  wmoy=0.0;
  ecr=0.0;
  ecp=0.0;
  ecl=0.0;

  Rimin=(vector){syssizex,syssizey,syssizez};
  Rimax=vect0;
  Rimean=vect0;
  // Compute mean values for the step 1 (only check the interaction forces) 
  for(idparti=1;idparti<=npart;idparti++)
    {
      Rimean.x+=particle[idparti].Ri.x;
      Rimean.y+=particle[idparti].Ri.y;
      Rimean.z+=particle[idparti].Ri.z;
      if(particle[idparti].Ri.x+particle[idparti].radius>Rimax.x){Rimax.x=particle[idparti].Ri.x+particle[idparti].radius;}
      if(particle[idparti].Ri.x-particle[idparti].radius<Rimin.x){Rimin.x=particle[idparti].Ri.x-particle[idparti].radius;}
      if(particle[idparti].Ri.y+particle[idparti].radius>Rimax.y){Rimax.y=particle[idparti].Ri.y+particle[idparti].radius;}
      if(particle[idparti].Ri.y-particle[idparti].radius<Rimin.y){Rimin.y=particle[idparti].Ri.y-particle[idparti].radius;}
      if(particle[idparti].Ri.z+particle[idparti].radius>Rimax.z){Rimax.z=particle[idparti].Ri.z+particle[idparti].radius;}
      if(particle[idparti].Ri.z-particle[idparti].radius<Rimin.z){Rimin.z=particle[idparti].Ri.z-particle[idparti].radius;}
		
      vit_norm=sqrt(particle[idparti].Vi.x*particle[idparti].Vi.x+particle[idparti].Vi.y*particle[idparti].Vi.y+particle[idparti].Vi.z*particle[idparti].Vi.z);
      // Translatiobnal kinetic energy
      ecl+=0.5*particle[idparti].mass*pow(vit_norm,2.0)*pow(unity,2.0);
      // Mean velocity
      vmoy+=vit_norm;
      wit_norm=sqrt(particle[idparti].Wi.x*particle[idparti].Wi.x+particle[idparti].Wi.y*particle[idparti].Wi.y+particle[idparti].Wi.z*particle[idparti].Wi.z);
      //
      wmoy+=wit_norm;
      // Angular kinetic energy
      ecr+=0.5*particle[idparti].inertia*pow(wit_norm,2.0);
      // Potential gravitational energy
      ecp+=-particle[idparti].mass*(particle[idparti].Ri.x*gravity.x+particle[idparti].Ri.y*gravity.y+particle[idparti].Ri.z*gravity.z)*unity;
     
      if(wit_norm>wmax)
	{
	  wmax=wit_norm;
	  vwmax=vit_norm;
	  npwmax=idparti;
	}
    }
    
  Rimean.x=Rimean.x/npart;
  Rimean.y=Rimean.y/npart;
  Rimean.z=Rimean.z/npart;
  vmoy=vmoy/npart;
  wmoy=wmoy/npart;
  nzcoor=num_coor();
  sxy=box_size.x*box_size.y;
  if(ChoixTypeCalcul==3)
    {
      compacite=compacity_z(0.0,Rimax.z,sxy);
    }
  else
    {
      compacite=compacity_z(0.25*Rimax.z,0.75*Rimax.z,sxy);
    }

  // Total force applied on the objects
  if(Fsph_obj)
    {
      fobjects=vect0;
      for(idparti=npart+nsurf+1;idparti<=npart+nobj;idparti++)
	{
	  fobjects.x += particle[idparti].Fi.x;
	  fobjects.y += particle[idparti].Fi.y;
	  fobjects.z += particle[idparti].Fi.z;
	}
    }
  // Average stresses on the boundary conditions
			
  sr_supwall=particle[npart+6].Fi.z/(sxy*unity*unity);
   
  //**************************************
  // Screen printing and writing of the log file writing (screen -> some essential informarion // logfile -> more detailed information
  if(istep==1||istep%ndodisplay==0||istep==niter)
    {
      // print screen 
      fprintf(stdout,"\n");
      fprintf(stdout,"  Current Iteration : %d      \n",istep);
      fprintf(stdout,"    zmoy %lf zmin %lf zmax %lf \n",Rimean.z,Rimin.z,Rimax.z);
      fprintf(stdout,"    Overlap mean %e min %e max %e \n",overlap[0],overlap[1],overlap[2]);
      fprintf(stdout,"    Indfric %e - Id particle with Wmax %d\n",indfric,npwmax);
			
			
      //********
      // Print some information for the logfile - compute first the coordination number of the largest angular velocity particle
      fprintf(flogfile,"  *************************** \n");
      fprintf(flogfile,"  Current Iteration %d time(s) %e \n",istep,timet);
      fprintf(flogfile,"    <x> %lf xmin %lf xmax %lf \n",Rimean.x,Rimin.x,Rimax.x);
      fprintf(flogfile,"    <y> %lf ymin %lf ymax %lf \n",Rimean.y,Rimin.y,Rimax.y);
      fprintf(flogfile,"    <z> %lf zmin %lf zmax %lf \n",Rimean.z,Rimin.z,Rimax.z);
      fprintf(flogfile,"    vmoy %lf  wmoy %lf \n",vmoy,wmoy);
			
      fprintf(flogfile,"    Particle with the largest angular velocity id %d Wmax %f vwmax %f \n",npwmax,wmax,vwmax);
      //fprintf(flogfile,"    Overlap mean %e - min %e - max %e n1 %d n2 %d \n",overlap[0],overlap[1],overlap[2],(int)overlap[3],(int)overlap[4]);
      //fprintf(flogfile,"    Contact: tot %u pot %u gran %u slide %u - friction index %f\n");
    }
  // First line of results.dat file
  if(istep==1)
    {
      fresultfile=fopen("results.dat","w");
      // In all cases
      fprintf(fresultfile,"%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s","#Times_(s)","Iteration","Zmean_(u)","Zmin_(un)","Zmax_(un)","Compacity","Ecl_(J)","Ecr_(J)","Ecp_(J)","Ncoor_num ");
      /*
      // Depend of the boundary conditions
      if(Fcyl_bond)
      {
      fprintf(fresultfile,"\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s","Diamcyl(u)","sr_latcyl(Pa)","Fcyl.x(N)","Fcyl.y(N)","Fcyl.z(N)");
      }
				
      // Depend of the type of simulation
      if(ChoixTypeCalcul==3||(ChoixTypeCalcul==5))
      {
      fprintf(fresultfile,"\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s","Zplateau_(un)","Vplateau_(un/s)","Fsup.x_(N)","Fsup.y_(N)","Fsup.z_(N)","Finf.x_(N)","Finf.y_(N)","Finf.z_(N)","sr_supwall_(Pa)");
      }
      if(Fsph_obj)
      {
      fprintf(fresultfile,"\t%-12s\t%-12s\t%-12s","Fobj.x_(N)","Fobj.y_(N)","Fobj.z_(N)");
      if(ChoixTypeCalcul==5){fprintf(fresultfile,"\t%-12s","Fcis.y_(N)");}
      }

      if(Fclust)
      {
      fprintf(fresultfile,"\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s\t%-12s","<Npp>","<Npp-pond>","<Df>","<Df-pond>","<Comp>","<Comp-pond>","nc");
      }*/

      fprintf(fresultfile,"\n");
    }
		
  // Printing results
  // For all cases
  fprintf(fresultfile,"%e\t%-12d\t%e\t%e\t%e\t%e\t%e\t%e\t%e\t%12.3f",timet,istep,Rimean.z,Rimin.z,Rimax.z,compacite,ecl,ecr,ecp,nzcoor);
			
  // Depend of the boundary conditions
  /*
    if(Fcyl_bond)
    {
    fprintf(fresultfile,"\t%e\t%e\t%e\t%e\t%e",diamcyl,sr_latcyl,particle[npart+7].Fi.x,particle[npart+7].Fi.y,particle[npart+7].Fi.z);
    }
			
			
    // Depend of the studied case
    if((ChoixTypeCalcul==3)||(ChoixTypeCalcul==5))
    {
    fprintf(fresultfile,"\t%e\t%e\t%e\t%e\t%e\t%e\t%e\t%e\t%e",z_upwall,particle[npart+6].Vi.z,particle[npart+6].Fi.x,particle[npart+6].Fi.y,particle[npart+6].Fi.z,particle[npart+1].Fi.x,particle[npart+1].Fi.y,particle[npart+1].Fi.z,sr_supwall);
    }
			

    if(Fsph_obj)
    {
    fprintf(fresultfile,"\t%e\t%e\t%e",fobjects.x,fobjects.y,fobjects.z);
    if(ChoixTypeCalcul==5){fprintf(fresultfile,"\t%e",particle[npart+1].Fi.y+fobjects.y);}
    }
    if(Fclust)
    {
    freturn=cluster_properties(freturn);
    fprintf(fresultfile,"\t%e\t%e\t%e\t%e\t%e\t%e\t%12d",freturn[1],freturn[2],freturn[3],freturn[4],freturn[5],freturn[6],(int)freturn[0]);
    }
			
    if((ChoixTypeCalcul==2)&&(forceHCSS))
    {
    fprintf(fresultfile,"%e\t%e\t%e\t%e",particle[npart+2].Fi.y,particle[npart+3].Fi.y,particle[npart+1].Fi.y,particle[npart+2].Vi.y);
    }
  */
  fprintf(fresultfile,"\n");
  fflush(stdout);
  fflush(fresultfile);
	  
}
   

			
					
double num_coor()
{
  int idparti,idpartj;
  double xparti,yparti,zparti,xpartj,ypartj,zpartj,rparti,rpartj;
  double xdist,ydist,zdist,dcontact,dist2;
  int ncoor,icoor;
  double nu_coor;
  ncoor=0;
  //printf("nzoor\n");
  for(idparti=1;idparti<=npart;idparti++)
    {
      xparti=particle[idparti].Ri.x;
      yparti=particle[idparti].Ri.y;
      zparti=particle[idparti].Ri.z;
      rparti=particle[idparti].radius;
      //printf("%d ",idparti);
      icoor=0;
      for(idpartj=1;idpartj<=npart+nobj;idpartj++)
	{
		   
	  xpartj=particle[idpartj].Ri.x;
	  ypartj=particle[idpartj].Ri.y;
	  zpartj=particle[idpartj].Ri.z;
	  rpartj=particle[idpartj].radius;
	  // Need change for
      
	  if(idpartj<=npart)
	    {
	      //Periodic condition
				 
	      // periodic boundary conditions for x2
	      if((xpartj>xparti)&&(xpartj-xparti>xparti+syssizex-xpartj)){xpartj-=syssizex;}
	      else if((xpartj<xparti)&&(xparti-xpartj>xpartj+syssizex-xparti)){xpartj+=syssizex;}
				  
	      // periodic boundary conditions for x2
	      if((ypartj>yparti)&&(ypartj-yparti>yparti+syssizey-ypartj)){ypartj-=syssizey;}
	      else if((ypartj<yparti)&&(yparti-ypartj>ypartj+syssizey-yparti)){ypartj+=syssizey;}
				  
	      // periodic boundary conditions for x2
	      if((zpartj>zparti)&&(zpartj-zparti>zparti+syssizez-zpartj)){zpartj-=syssizez;}
	      else if((zpartj<zparti)&&(zparti-zpartj>zpartj+syssizez-zparti)){zpartj+=syssizez;}

				  
	    }
      
	  xdist=xparti-xpartj;
	  ydist=yparti-ypartj;
	  zdist=zparti-zpartj;
	  dist2=xdist*xdist+ydist*ydist+zdist*zdist;
	  dcontact=rparti+rpartj+hmax;
	  dcontact=dcontact*dcontact;
	  if((dist2 <= dcontact)&&(idparti!=idpartj))
	    {
	      if((particle[idparti].radius>0.0)&&(particle[idpartj].radius>0.0))
		{
		  ncoor++;
		  icoor++;
		  //printf("%d ",idpartj);
		}
	    }
		
	}
	  
      //printf("* %d\n",icoor);
    }
	
  nu_coor=((double)ncoor)/(npart);
  return nu_coor;
	
}
  
  

// If modular program, don't forget to include times.h and stdlib.h
/**
 *\fn void end_program(void)
 *\brief This function is called to stop job. It prints any error message, computes the elapsed time and displays some environnement variables 
 *\param void	
 *\return void
 */
void end_program(void)
{
  clock_t CPU_time;   
  time_t local_time,CPUt_s;
  struct tm CPUt_dhms;
  char *username,*currentpath;


  deallocate_variables();
  // Generate error message in standard error stream (stderr)

  if(ierror!=0)
    {
#if defined(WIN32) || defined(WIN64)
      HANDLE Ecran = GetStdHandle(STD_OUTPUT_HANDLE);
      SetConsoleTextAttribute(Ecran, FOREGROUND_GREEN);
# endif
      fprintf(stderr,"Job aborted : exit status %d \n",ierror);

      fflush(stderr);
    }


  // compute the local et elapsed CPU times (function clock must divided by CLOCKS_PER_SEC)
  CPU_time=clock();
  time(&local_time); 
  CPUt_s=CPU_time/CLOCKS_PER_SEC;
  CPUt_dhms=*localtime(&CPUt_s); 

  // Get some environnement variables
  username=getenv("USERNAME");
  currentpath=getenv("PWD");

  fprintf(stdout,"===============================================================================\n");
  fprintf(flogfile,"===============================================================================\n");	
  fprintf(stdout," Job done: %s \n",ctime(&local_time));
  fprintf(flogfile," Job done: %s \n",ctime(&local_time));
  fprintf(stdout,"Elapsed CPU time : %dD/%dh/%dm/%ds (%li sec)\n",CPUt_dhms.tm_mday-1,CPUt_dhms.tm_hour-1,CPUt_dhms.tm_min,CPUt_dhms.tm_sec,CPUt_s);
  fprintf(flogfile,"Elapsed CPU time : %dD/%dh/%dm/%ds (%li sec)\n",CPUt_dhms.tm_mday-1,CPUt_dhms.tm_hour-1,CPUt_dhms.tm_min,CPUt_dhms.tm_sec,CPUt_s);
  fprintf(flogfile,"User: %s \n",username);
  fprintf(flogfile,"Work directory: %s \n",currentpath);
  fprintf(stdout,"===============================================================================\n");
  fprintf(flogfile,"===============================================================================\n");
  fclose(flogfile);
}

	

/**
 *\fn void print_about(void)
 *\brief function displaying typical program information in terminal
 *\param void	
 *\return void
 */
	
void print_about(void)
{
  fprintf(stdout,"\n");
  fprintf(stdout,"\n");
  fprintf(stdout,"       *********************************************************************************\n");
  fprintf(stdout,"       * demGCE: Discrete element modeling of Granular materials for Civil Engineering *\n");
  fprintf(stdout,"\n");
  fprintf(stdout,"       * Numerical simulation of discrete spherical particles\n");
  fprintf(stdout,"       * Developped by : *\n");
  fprintf(stdout,"       *             Research Centre of Ecole Mines Douai                *\n");
  fprintf(stdout,"       *             Department of Civil and Environnemental Engineering        *\n");
  fprintf(stdout,"       *             Version: $Revision: 1.65 $ - $Date: 2013/07/16 18:07:23 $   *\n");
  fprintf(stdout,"       **************************************************************************\n");
  fprintf(stdout,"\n");
}
